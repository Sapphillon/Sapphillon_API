// Copyright 2025 Yuta Takahashi
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package sapphillon.v1;

import "google/rpc/status.proto";
import "sapphillon/v1/plugin.proto";

// Service for managing plugins.
// Allows clients to list and query available plugin packages
// that can be used in workflows.
service PluginService {
  // Lists all available plugin packages.
  // Returns a paginated list of plugin packages that can be installed or used.
  rpc ListPlugins(ListPluginsRequest) returns (ListPluginsResponse);

  // Installs a plugin from a given URI.
  //
  // This API is experimental and is likely to change.
  //
  // TODO:
  // - Repository support
  // - Checksum support
  // - Certificate support
  //
  // Security considerations:
  // - Authentication and authorization: Callers must be authenticated and
  //   authorized to install plugins. This is typically an admin-only operation.
  // - Plugin signature verification: Implementations MUST verify plugin
  //   signatures before installation (see TODO for certificate support).
  // - Sandboxing: Installed plugins SHOULD be isolated/sandboxed to prevent
  //   unauthorized access to system resources.
  //
  // Error conditions:
  // - INVALID_ARGUMENT: The URI is malformed, uses a disallowed scheme, or
  //   the plugin package is invalid.
  // - ALREADY_EXISTS: A plugin with the same package ID is already installed.
  // - PERMISSION_DENIED: The caller does not have permission to install plugins.
  // - FAILED_PRECONDITION: Version conflicts or dependency issues prevent
  //   installation.
  //
  // On error, the `status` field of `InstallPluginResponse` is populated with
  // a corresponding `google.rpc.Status`.
  rpc InstallPlugin(InstallPluginRequest) returns (InstallPluginResponse);

  // Uninstalls a plugin by its package ID.
  //
  // This API is experimental and is likely to change.
  //
  // Security considerations:
  // - Authentication and authorization: Callers must be authenticated and
  //   authorized to uninstall plugins. This is typically an admin-only operation.
  //
  // Error conditions:
  // - NOT_FOUND: The specified `package_id` does not correspond to any
  //   installed plugin.
  // - FAILED_PRECONDITION: The plugin is currently in use by one or more
  //   active workflows and cannot be uninstalled until those workflows are
  //   updated or terminated.
  // - PERMISSION_DENIED: The caller does not have sufficient permission to
  //   uninstall the plugin.
  //
  // On error, the `status` field of `UninstallPluginResponse` is populated
  // with a corresponding `google.rpc.Status`.
  rpc UninstallPlugin(UninstallPluginRequest) returns (UninstallPluginResponse);
}

// Request message for listing plugins.
message ListPluginsRequest {
  // The maximum number of plugins to return.
  // The service may return fewer than this value.
  // If zero, the server will pick an appropriate default.
  int32 page_size = 1;

  // A page token, received from a previous `ListPlugins` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 2;
}

// Response message for listing plugins.
message ListPluginsResponse {
  // A list of available plugin packages.
  repeated PluginPackage plugins = 1;

  // A token to retrieve the next page of results.
  // If this field is empty, there are no more results.
  string next_page_token = 2;

  google.rpc.Status status = 3;
}

// Request message for installing a plugin.
message InstallPluginRequest {
  // The URI of the plugin to install.
  //
  // Required. This field must not be empty.
  //
  // Security constraints:
  // - Only HTTPS-based URIs are allowed (e.g. https://example.com/plugin.pkg).
  //   Implementations MUST reject non-HTTPS schemes such as file://, http://,
  //   ftp://, ssh://, and other potentially dangerous or untrusted schemes.
  // - Servers SHOULD validate the host and path against an allowlist or
  //   blocklist of trusted plugin sources (e.g. known repositories or domains)
  //   before attempting to download or install the plugin.
  // - Servers MUST enforce reasonable limits on the size of the downloaded
  //   plugin package and on download time to mitigate resource exhaustion
  //   (e.g. maximum bytes, timeouts, and concurrent download limits).
  // - If a custom or repository-specific scheme is supported, its semantics
  //   and security properties SHOULD be documented and validated similarly.
  //
  // If this field is empty or does not conform to the expected format/scheme,
  // the server MUST fail the request and return an `INVALID_ARGUMENT` error
  // in the `status` field of `InstallPluginResponse`.
  string uri = 1;
}

// Response message for installing a plugin.
message InstallPluginResponse {
  // The installed plugin package.
  //
  // On success (`status.code == google.rpc.Code.OK`), this field contains
  // the fully installed plugin package.
  //
  // On failure or partial installation (`status.code != OK`), this field
  // MUST NOT be relied upon and should be treated as unset/undefined by
  // clients. Implementations SHOULD leave this field empty in such cases.
  PluginPackage plugin = 1;

  // Result of the install operation.
  //
  // - `status.code == OK`: the plugin was installed successfully and
  //   `plugin` is populated with the installed package.
  // - `status.code != OK`: the install failed or only partially completed.
  //   In this case, clients MUST ignore `plugin`. Implementations MAY
  //   use `status.details` to convey additional information about any
  //   partial installation state (e.g., which step failed) rather than
  //   encoding partial state in `plugin`.
  google.rpc.Status status = 2;
}

// Request message for uninstalling a plugin.
message UninstallPluginRequest {
  // The package ID of the plugin to uninstall.
  //
  // Required. This must be the exact `package_id` of an installed plugin
  // as returned by `ListPlugins` or `InstallPlugin`.
  //
  // If this field is empty or does not conform to the expected format, the
  // server MUST fail the request and return an `INVALID_ARGUMENT` error in
  // the `status` field of `UninstallPluginResponse`.
  //
  // If the specified package does not exist or is already uninstalled, the
  // server MUST return a `NOT_FOUND` error in the `status` field of
  // `UninstallPluginResponse`.
  string package_id = 1;
}

// Response message for uninstalling a plugin.
message UninstallPluginResponse {
  google.rpc.Status status = 1;
}
